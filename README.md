# parallel_key_value_store

## Files Included
* client.cpp: Client program to communicate with server using TCP sockets. Repeatedly take in user requests via STDIN using the following format
    <OP> <Key> <Value>
  where OP is one of the CRUD operations encoded as 'C' for Create, 'R' for Read, 'U' for Update, and 'D' for Delete. <Value> is not needed for 'R' and 'D'. Key and Value are just strings for now (TODO: store files, both binary and text, later on?). When specifying requests, format the string as <OP> <Key> <Value>. Continuously send such request strings to the server. If done sending requests, send a "DONE" message to the server and exit cleanly.
* server.cpp: MPI Server program to handle client requests. Workload is divided as follows:
  1. P0 - The central master node that processes incoming requests. Prior to setting up TCP connections (spawning a thread for each client), it hashes all the nodes N times, where N is the number of slave nodes and stores all the hashes in a sorted vector. A mapping of the hashes to their corresponding nodes is maintained. Multi-threaded with pthreads to enable concurrent processing of multiple requests. Each thread continuously receives and parses client requests, performs consistent hashing on the keys, and assigns them to the appropriate node by performing a binary search on the list of node hashes and looking up the right node in the mapping of hashes to nodes. If it's a 'R' op, receive the corresponding value from the node and send it back to the client. If a "DONE" message is received, terminate the thread function. 
  2. P1...PN - These are the slave nodes that are responsible for performing the CRUD operations on the data. Since each node may receive multiple requests at a time, maintain a vector of vector of chars based on the number of clients. Each maintains an instance of a class object that consists of a hashmap of strings for storing the data and methods for the CRUD operations. If the operation is 'R', then the node attempts to find the matching value for the key. If such a value is found, then it is sent back to P0. Else, a failure message is returned.
* kv_store.h/kv_store.cpp: Header and source files for implementing the key-value store operations. Class containing a member variable of a hash map of strings to strings and the CRUD methods to operate on the stored data. (TODO: use SQL database instead of simply a hash map?)
  
## Testing
We will test our system using different number of worker nodes (1, 2, 4, and 8 for now). The number of clients will be the same as the number of worker nodes (TODO: randomly fail some nodes and reintroduce them later to test how well our consistent hashing scheme redistributes the workload). Within each thread function in P0 of the server, time how long it takes for the worker node to perform the desired op and return a result (if any). Also, in P0, see how many requests on average get assigned to each node to determine load balancing.  
